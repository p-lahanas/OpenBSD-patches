Summary
-------
prom-exporter throws a segmentation fault when closing multiple 
invalid requests.

Analysis
--------
The provided prom-exporter binary and prom-exporter.core files were analysed
with gdb, giving the following output.

	planhas@peter ~$gdb ./prom-exporter -c prom-exporter.core
	Core was generated by `prom-exporter'.
	Program terminated with signal 11, Segmentation fault.
	Loaded symbols for /home/planhas/prom-exporter
	Reading symbols from /usr/lib/libc.so.96.0...done.
	Loaded symbols for /usr/lib/libc.so.96.0
	Reading symbols from /usr/libexec/ld.so...Error while reading 
	shared library symbols:
	Dwarf Error: wrong version in compilation unit header 
	(is 4, should be 2) [in module /usr/libexec/ld.so]
	#0  free_req (req=0xdfdfdfdfdfdfdfdf) at main.c:100
	100     main.c: No such file or directory.
        	in main.c

The reason for the segfault in free_req was further examined by checking the
stack trace.

	(gdb) bt
	#0  free_req (req=0xdfdfdfdfdfdfdfdf) at main.c:100
	#1  0x00000690b197c577 in reactor_loop (lsock=3, registry=0x693606e2600, 
	settings=0x7f7ffffc9200) at main.c:405
	#2  0x00000690b197baa9 in main (argc=3, argv=0x7f7ffffc9308) at 
	main.c:253
	Current language:  auto; currently minimal

As revealed by the stack trace above, the req variable is pointing to a memory
address of 0xdfdfdfdfdfdfdfdf which is clearly invalid. Malloc on OpenBsd fills
freed memory with 0xdf but this pointer is to an invalid address.
This indicates a use after free bug.

After examining the free_req function, it was noted that the parameter
(struct req *req) is not checked to be invalid before accessing/freeing any 
memory. It can be concluded that derefencing the invalid pointer passed to 
free_req caused the segfault.

While this can be fixed by modifying the free_req function (set freed pointers 
to NULL and check for NULL before dereferencing), it is likely the calling 
function (reactor_loop) caused the issue as it should not have passed an invalid 
pointer when calling free_req.

The stack trace revealed that reactor_loop passed an invalid pointer to free_req 
on line 405. 

After examining the goto statement check_pfds, it was noted each request was 
handled in a loop. After an invalid request, the allocated memory for the 
request is freed by accessing the address through the parser variable. 
Line 405:
	free_req(parser->data);

However, the parser variable remained the same on each iteration but should be 
unique for each connection. This means if two invalid requests occur, it is 
possible that the same req is freed twice resulting in and error similar to that
shown in the core dump.

Proposed Fix
------------
Ensure that the parser variable in reactor_loop is updated when we iterate 
through the current requests. 
We can add the following line at the start of the loop to update the parser.
	parser = req->parser;